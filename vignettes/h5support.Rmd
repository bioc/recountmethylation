---
title: "HDF5 support"
author:
  - name: Sean K. Maden
  - name: Reid F. Thompson
  - name: Kasper D. Hansen
  - name: Abhi Nellore
package: recountmethylation
abstract: >
   Vignette for working with `recountmethylation` HDF5 database contents, available at https://recount.bio/data. See the main vignette, recountmethylation.Rmd, for details.
vignette: >
    %\VignetteDepends{RCurl}
    %\VignetteEngine{knitr::knitr} 
    %\VignetteIndexEntry{recountmethylation user's guide} 
    %\usepackage[UTF-8]{inputenc}
output:
    BiocStyle::html_document:
        toc: true
        tocfloat: true
        code_folding: show
    pdf_document: default
---

```{r setup}
library(recountmethylation)
knitr::opts_chunk$set(eval = TRUE, echo = TRUE, 
                      warning = FALSE, message = FALSE)
```

# Introduction

This package provides accessor functions to query the `recountmethylation` 
database file, `remethdb2.h5`. The database stores relatively large red- and 
green-channel raw signal tables in 
[hierarchical data format](https://www.hdfgroup.org/), or "HDF5". These DNAm 
signal tables have been extracted directly from IDAT files generated using the 
Illumina HM450k array DNAm array platform. DNAm arrays were accessed from 
the [Gene Expression Omnibus](https://www.ncbi.nlm.nih.gov/geo/) via the 
GEO DataSets database.

To help inform sample queries, the HDF5 database includes a sample metadata 
table learned from GEO GSE 
[SOFT](https://www.ncbi.nlm.nih.gov/geo/info/soft.html) files. 
When specifying samples whose DNAm data to return, several arguments assist 
with querying and accessing the database files. For instance, returned objects 
can be either a list of datasets or a single object of class `RGChannelSet`, 
which inherits properties from the `SummarizedExperiment` class.

# Disclaimer
On loading `recountmethylation`, a disclaimer is provided.
In summary, the `recountmethylation` R package can aid and expand research capabilities 
in epigenetics cross-study analysis.
Contained data does not presently build live, and presently data reflects 
assays and metadata available as of March 2019.
Data validation can be performed using `recountmethylation::rg_from_geo()`, and users
may find the packages `GEOquery` and `GEOmetadb` useful.

# Installation

The `recountmethylation` package can be installed from GitHub using `devtools::install_github("metamaden/recountmethylation")`


# Data access

`recountmethylation` requires as input a path to a valid `recountmethylation` HDF5 database. 
This vignette uses a small test dataset called `remethdbtest.h5`, which includes DNAm red and green signal at chr22 for 30 samples. It can be downloaded [here](). The full database can be downloaded [here]().

First, enter the path to the test dataset and summarize its contents as below.

```{r h5_details}
path = system.file("extdata", "testh5", package = "recountmethylation")
fn = list.files(path)
dbpath = paste0(path, "/", fn)
rhdf5::h5ls(dbpath)
```

Note that dataset row and column names are stored separately from data matrices, which are denoted as "[dataset].[row/column]names". Data is homogeneous for each 
object in the HDF5 file. That is, each data entity has a single type 
(e.g. `FLOAT`, `STRING`, `STRING`).

To identify and characterize samples in the HDF5 database, first access the 
sample metadata.

```{r get_gsm_metadata}
# get full gsm metadata
mdp = data_mdpost(dbpath, dsn = "mdpost")
dim(mdp)
```

The test dataset contains a small subset of the data available in 
recount methylation. Here, we will query the samples under the GSM records [GSM2465267](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM2465267) 
and 
[GSM2814572](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM2814572), 
which are in turn under the GSE records
[GSE93933](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE93933) and
[GSE105018](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE105018). 

Next, check sample types and construct a sample query as follows.

```{r make_gsm_query}
# check which samples available in h5 db
dsn = "redsignal"

# redsignal rownames (gsm ids)
rs.gsm = rhdf5::h5read(dbpath, paste(dsn, "rownames", sep = ".")) 
rs.gsm = gsub("\\..*", "", rs.gsm)
mdf = mdp[mdp$gsm %in% rs.gsm,]

# available tissue terms
unique(unlist(strsplit(mdf$tissue, ";"))) 

# get sample id query by tissue term
termi = "blood"
var.query = "tissue"
which.index = 1:2
which.gsm = which(grepl(paste0(".*", termi, ".*"), 
    mdf[,var.query]))[which.index]
gsmvi = mdf$gsm[which.gsm]

# sample ids
gsmvi
```

For full details about the sample metadata, you may consult the package manuscript. In summary, the variables `disease` and `tissue` contain learned annotations separated by `;`, where samples can have one of several labels under the same variable. In terms of queries that use regular expressions, exact matches may use 
`grepl(paste0("(^|;)", myterm, "($|;)", mdvariable)` 
and approximate matches may use `grepl(paste0(".*", myterm, ".*", mdvariable)`, 
where `myterm` is the term of interest and `mdvariable` is the column queried. 

Next, query a probe subset by genomic location (here we use `chrname` or chr22) using the array annotation file.

```{r make_cg_query}
anno.name = "IlluminaHumanMethylation450kanno.ilmn12.hg19"
man = eval(parse(text = paste(anno.name, "Manifest", sep = "::")))
loc = eval(parse(text = paste(anno.name, "Locations", sep = "::")))
chrname = "chr22"
# cpgs of interest
cgfilt = rownames(loc[grepl(paste0("^", chrname, "$"), loc$chr),])
# vector of queries addresses
cgvi = unique(c(man[cgfilt,]$AddressA, man[cgfilt,]$AddressB))
length(cgvi)
```

With the queries constructed, we can proceed to extracting and storing the 
methylation datasets for analysis.

# Data queries
DNA methylation signal data can be retrieved in one of two ways using the 
`recountmethylation::getrg()` function. First, data can be returned as 
an object of class `RGChannelSet`, a type of `SummarizedExperiment` 
object, by setting the `data.type` argument to 'se'. 

```{r get_se_set}
# make df list from h5 db query
se.rgi = getrg(gsmv = gsmvi, cgv = cgvi, all.cg = FALSE, 
    dbn = dbpath, data.type = "se", metadata = TRUE, verbose = FALSE)
```
```{r check_se_set}
dim(se.rgi)
dim(minfi::pData(se.rgi))
dim(minfi::getRed(se.rgi))
dim(minfi::getBeta(se.rgi))
```

This class conveniently stores signal data, sample metadata, 
genome annotations, and other useful metadata in a single object. 

Alternatively, we can return a list of datasets.

```{r get_dflist}
ldat.rgi = getrg(gsmv = gsmvi, cgv = cgvi, all.cg = FALSE, 
    dbn = dbpath, data.type = "df", metadata = TRUE, verbose = FALSE)
```
```{r check_dflist}
length(ldat.rgi)
dim(ldat.rgi[["redsignal"]])
dim(ldat.rgi[["metadata"]])
```

It's likely the best data type will vary with the particular 
query and research question. It may be preferable for queries of over 
20 non-consecutive samples to be processed in a loop over smaller queries.

# Validation of sample data
Because data is constantly being added and revised in GEO, it can be 
useful to validate retrieved data with the latest available data. We can 
readily validate the retrieved sample DNA methylation data against a 
query to the current IDAT files in GEO GSM supplement from GEO Data Sets. 

There are 2 IDATs roughly 4.5 Mb in size expected per GSM, one for each 
color channel. The following will perform fresh downloads of the IDATs 
for the queried GSMs to the current directory:

```{r idat_dl}
dn = "" # download idats to cwd
bnv = c() # store the idat basenames
dfn = "./idats/"
geoquery <- gds_idatquery(gsmvi, dfp = dfn)
geoquery
```

The IDAT basenames are the unique IDAT filenames excluding the 
strings "_Red.idat" and "_Grn.idat". We use the basename vector above to 
read downloaded IDATs into a new `RGChannelSet` object with minfi, then 
subset on chromosome 22 probes as above.

```{r read_idatdl}
rgdl = minfi::read.metharray(basenames = geoquery[["basenames"]])
colnames(rgdl) = gsub("_.*", "", colnames(rgdl)) # extract gsm ids
rgdl = rgdl[rownames(rgdl) %in% cgvi,]
```
```{r check_rgdl}
dim(rgdl)
identical(rownames(rgdl), rownames(se.rgi)) # check that cg addresses match
```

Now check for consistency between the methylation data returned 
from the `recountmethylation` query and the fresh data downloads.

```{r rg_validate}
evalv = c()
for(c in colnames(rgdl)){
    evalv = c(evalv, identical(as.numeric(minfi::getRed(rgdl[,c])), 
        as.numeric(minfi::getRed(se.rgi[,c]))))
    evalv = c(evalv, identical(as.numeric(minfi::getGreen(rgdl[,c])), 
        as.numeric(minfi::getGreen(se.rgi[,c]))))
}
```
```{r check_rg_eval}
table(evalv == TRUE)
```

# Basic preprocessing
Basic preprocessing of the `RGChannelSet` object can be performed with 
functions from the `minfi` package. In general, the `RGChannelSet` is 
larger than derived objects of class `MethylSet`, `GenomeRatioSet`, etc. 
though the latter excludes full signal information such as for control 
probes. We can obtain the raw Beta-values and noob-normalized 
Beta-values in more compact `MethylSet` objects as follows.

```{r preprocess_list}
library(minfi)
lpre = list(se = list(),
    mv = list(), umv = list(),
    bv = list())
lpre[["se"]][["raw"]] = se.raw = preprocessRaw(se.rgi)
lpre[["se"]][["nb"]] = se.noob = preprocessNoob(se.rgi)

lpre[["mv"]][["raw"]] = getMeth(se.raw)
lpre[["mv"]][["nb"]] = getMeth(se.noob)

lpre[["umv"]][["raw"]] = getUnmeth(se.raw)
lpre[["umv"]][["nb"]] = getUnmeth(se.noob)

lpre[["bv"]][["raw"]] = getBeta(se.raw)
lpre[["bv"]][["nb"]] = getBeta(se.noob)
```

We can compare raw Beta-values to noob-normalized Beta-values:

```{r compare_bvalmeans}
bv.raw.means = apply(lpre$bv$raw, 1, mean)
bv.noob.means = apply(lpre$bv$nb, 1, mean)
bv.dif = bv.noob.means - bv.raw.means
summary(bv.dif)
hist(bv.dif, main = "Noob - Raw\n(mean Beta-value differences)")
```

# Session info

```{r}
sessionInfo()
```
