---
title: "Data Analyses"
author:
- Sean K. Maden
- Reid F. Thompson
- Kasper D. Hansen
- Abhinav Nellore
date: "`r format(Sys.time(), '%d %B, %Y')`"
bibliography: bibliography.bib
package: recountmethylations
vignette: > 
  %\VignetteIndexEntry{Data Analyses}
  %\VignetteDepends{RCurl}
  %\usepackage[UTF-8]{inputenc} 
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  BiocStyle::html_document:
    code_folding: show
    toc: yes
    tocfloat: yes
  html_document:
    df_print: paged
    toc: yes
---

```{r setup, echo = FALSE}
suppressMessages(library(rhdf5))
suppressMessages(library(minfi))
suppressMessages(library(recountmethylation))
suppressMessages(library(knitr))
suppressMessages(library(ggplot2))
suppressMessages(library(gridExtra))
opts_chunk$set(eval = FALSE, echo = TRUE, 
               warning = FALSE, message = FALSE)
load("data_analyses/data_analyses.RData")
```

# Overview

This vignette walks through 3 analyses that use cross-study DNA methylation (DNAm) compilations accessed with the `recountmethylation` package. First, predicted and chronological ages are compared from the sample metadata. Then quality signals  (log2 median scale) are compared between samples stored using either formalin fixed paraffin-embedded (FFPE) or freezing. Finally, tissue-specific high DNAm variances are analyzed between adipose and liver. Note that versions of these analyses also appear in the manuscript @maden_human_2020.

## Vignette code and script

This vignette describes analysis steps in full, but with limited evaluations to ensure package build success. Code has been written and presented to accommodate extensibility to new and larger comparator groups. Unabridged code and helper function definitions to reproduce examples are contained in the `data_analyses_script.R` script.

## Data availability

This vignette makes use of the sample metadata, and two of the available `HDF5-SummarizedExperiment` compilations. Consult the `users_guide` vignette for details about the data objects and `recountmethylation` package. 

For this vignette, access the versioned metadata and load the DNAm compilation objects as follows.

```{r, eval = TRUE}
# load metadata
mddir <- system.file("extdata", "metadata", package = "recountmethylation")
mdpath <- paste0(mddir, "/", list.files(mddir))
md <- get(load(mdpath))
```
```{r}
# load methylset
gmdn <- "remethdb-h5se_gm_0-0-1_1590090412"
gm <- loadHDF5SummarizedExperiment(gmdn)
# load genomicratioset
grdn <- "remethdb-h5se_gr_0-0-1_1590090412"
gr <- loadHDF5SummarizedExperiment(grdn)
```

# Example 1: Comparing mined and predicted age

This example uses sample metadata to compare mined and predicted ages from the `age` and `predage` variables, respectively. Values in `age` were mined from GEO record metadata and are included with available age units. Values in `predage` were calculated from normalized DNAm Beta-values with `agep`, a function from the `wateRmelon` package that implements the Horvath biological age clock (@triche_low-level_2013).

## Make new variables and filter samples

Get samples for which both `age` and `predage` age are available. From `age`, make a new numeric variable `chron.age`.

```{r, eval = TRUE}
mdf <- md[!md$age == "valm:NA",]
mdf$chron.age <- as.numeric(gsub(";.*", "", gsub("^valm:", "", mdf$age)))
mdf$predage <- as.numeric(mdf$predage)
mdf <- mdf[!is.na(mdf$chron.age),]
mdf <- mdf[!is.na(mdf$predage),]
```

Next, make a new variable `stype` from `sampletype` and remove samples with missing values.

```{r, eval = TRUE}
mdf$stype <- as.character(gsub(";.*", "", gsub("^msraptype:", "", mdf$sampletype)))
mdf <- mdf[!is.na(mdf$stype),]
```

Now make a new variable `is.cx` from querying `cancer` in the `disease` term. This reflects whether a sample was likely from a cancer or a cancer patient.

```{r, eval = TRUE}
mdf$is.cx <- ifelse(grepl(".*cancer.*", mdf$disease), TRUE, FALSE)
```

Next, store the study-wise age differences in the `xdif` variable using the mean absolute difference (a.k.a. "MAD") between `chron.age` and `predage` across samples from the same study. Also store study sizes in the `ngsm` term for plotting. 

```{r, eval = TRUE}
xdif <- ngsm <- c()
for(g in unique(mdf$gseid)){
    mdff <- mdf[mdf$gseid==g, ]
    xdif <- c(xdif, mean(abs(mdff$chron.age - as.numeric(mdff$predage))))
    ngsm <- c(ngsm, nrow(mdff))
}
names(xdif) <- names(ngsm) <- unique(mdf$gseid)
```

Make a new filtered `mdff` data frame using the new variables. Retain likely non-cancer samples from studies with MAD <= 10 years. Pre- and post-filter sample and study abundances are summarized below.

```{r, eval = TRUE}
filt <- mdf$stype == "tissue" & !mdf$is.cx
filt <- filt & !mdf$gseid %in% names(xdif[xdif > 10])
mdff <- mdf[filt, ]
```

## Analyses and summary statistics

Perform statistical analyses of `mdf` (group 1) and `mdff` (group 2). First, generate multiple regressions for each. 

```{r, eval = TRUE}
lm1 <- lm(mdf$predage ~ mdf$chron.age + mdf$gseid + mdf$stype + mdf$is.cx)
lm2 <- lm(mdff$predage ~ mdff$chron.age + mdff$gseid)
```

Now perform analyses of variances (ANOVAs) on multiple regressions. Summarize variance percentages and p-values for covariates in each model.

```{r, eval = TRUE}
# anovas
av1 <- anova(lm1)
av2 <- anova(lm2)
# results summaries
sperc1 <- round(100*av1$`Sum Sq`[1:4]/sum(av1$`Sum Sq`), 2)
pval1 <- format(av1$`Pr(>F)`[1:4], scientific = TRUE, digits = 3)
sperc2 <- round(100*av2$`Sum Sq`[1:2]/sum(av2$`Sum Sq`), 2)
pval2 <- format(av2$`Pr(>F)`[1:2], scientific = TRUE, digits = 3)
# summary table
dan <- data.frame(Vperc1 = c(sperc1), 
                  Pval1 = c(pval1),
                  Vperc2 = c(sperc2, "-", "-"), 
                  Pval2 = c(pval2, "-", "-"), 
                  stringsAsFactors = FALSE)
rownames(dan) <- c("Chron.Age", "GSEID", "SampleType", "Cancer")
kable(dan, align = "c")
```

Now calcualte the R-squared, Spearman correlation coefficient (Rho), and MAD for each model.

```{r, eval = TRUE}
# rsquared
rsq1 <- round(summary(lm1)$r.squared, 2) # 0.76
rsq2 <- round(summary(lm2)$r.squared, 2) # 0.94
# correlation coefficient
rho1 <- round(cor.test(mdf$predage, mdf$chron.age, 
                      method = "spearman")$estimate, 2)
rho2 <- round(cor.test(mdff$predage, mdff$chron.age, 
                       test = "spearman")$estimate, 2)
# mean absolute difference
mad1 <- round(mean(abs(mdf$chron.age - mdf$predage)), 2)
mad2 <- round(mean(abs(mdff$chron.age - mdff$predage)), 2)
```

Finally, organize and display the results

```{r, eval = TRUE}
dss <- data.frame(group = c("1", "2"),
                  ngsm = c(nrow(mdf), nrow(mdff)),
                  ngse = c(length(unique(mdf$gseid)), length(unique(mdff$gseid))),
                  r.squared = c(rsq1, rsq2), rho = as.character(c(rho1, rho2)),
                  mad = c(mad1, mad2), stringsAsFactors = FALSE)
kable(dss, align = "c")
```

## Scatter plots of study errors and sample ages

Plot sample counts and MAD for each GSE record, with a vertical line at the 10-years MAD cutoff used for group 2 above.

```{r, eval = TRUE}
plot(xdif, ngsm, ylab = "Study Size (Num. GSM)", xlab = "Age Difference, MAD[Chron, Pred]")
abline(v = 10, col = "red")
```

Plot chronological and predicted ages for filtered samples in group 2.

```{r, eval = TRUE}
ggplot(mdff, aes(x = chron.age, y = predage)) +
  geom_point(size = 1.2, alpha = 0.2) + geom_smooth(method = "lm", size = 1.2) +
  theme_bw() + xlab("Chronological Age") + ylab("Epigenetic (DNAm) Age")
```

# Example 2: Signal comparison of FFPE and frozen samples

This section compares methylated and unmethylated signal (log2 median scale) between samples stored using either FFPE or fresh frozen (FF) strategies.

## Get samples with storage type information

Subset and summarize samples using the metadata. Retain just samples with available information in the `storage` variable, and define a new variable `sgroup`.

```{r, eval = TRUE}
mdf <- md[!md$storage == "NA",]
mdf$sgroup <- ifelse(grepl("FFPE", mdf$storage), "ffpe", "frozen")
sst <- get_sst(sgroup.labs = c("ffpe", "frozen"), mdf)
kable(sst, align = "c") # table display
```

## Use blocking to calculate signal log2 medians

Next, subset the loaded `MethylSet` object and extract the full signal matrices.

```{r}
gmf <- gm[, gm$gsm %in% mdf$gsm]
meth.all <- getMeth(gmf)
unmeth.all <- getUnmeth(gmf)
```

Next, prepare to get the log2 median signals for samples of interest. To manage data in active memory, process it in smaller units called blocks. First use the `get_blocks` helper function to specify 100-sample blocks.

```{r}
blocks <- getblocks(slength = ncol(gmf), bsize = 100)
```

Now calculate the sample array-wide log2 median signals for each specified block, and store results in `ds`. 

```{r}
ms <- matrix(nrow = 0, ncol = 2)
for(i in 1:length(blocks)){
  b <- blocks[[i]]
  gmff <- gmf[, b]
  methb <- as.matrix(meth.all[, b])
  unmethb <- as.matrix(unmeth.all[, b])
  l2meth <- l2unmeth <- c()
  for(c in 1:ncol(methb)){
    l2meth <- c(l2meth, log2(median(methb[,c])))
    l2unmeth <- c(l2unmeth, log2(median(unmethb[,c])))
  }
  ms <- rbind(ms, matrix(c(l2meth, l2unmeth), ncol = 2))
  message(i)
}
rownames(ms) <- colnames(meth.all)
colnames(ms) <- c("meth.l2med", "unmeth.l2med")
ds <- as.data.frame(ms)
ds$storage <- ifelse(grepl("FFPE", gmf$storage), "ffpe", "frozen")
```

## Signals plotted by storage type

Evaluate signal patterns across storage type using plots. First, make a 2d scatter plot of methylated and unmethylated signals, with coloration by storage type.

```{r, eval = TRUE}
ggplot(ds, aes(x = meth.l2med, y = unmeth.l2med, color = storage)) + 
  geom_point(alpha = 0.35, cex = 3) + theme_bw() +
  scale_color_manual(values = c("ffpe" = "orange", "frozen" = "purple"))
```

Next, make separate violin plots for each signal and storage type.

```{r, eval = TRUE}
vp <- matrix(nrow = 0, ncol = 2)
vp <- rbind(vp, matrix(c(ds$meth.l2med, paste0("meth.", ds$storage)), ncol = 2))
vp <- rbind(vp, matrix(c(ds$unmeth.l2med, paste0("unmeth.", ds$storage)), ncol = 2))
vp <- as.data.frame(vp, stringsAsFactors = FALSE)
vp[,1] <- as.numeric(vp[,1])
colnames(vp) <- c("signal", "group")
vp$col <- ifelse(grepl("ffpe", vp$group), "orange", "purple")
# make plot
ggplot(vp, aes(x = group, y = signal, color = group)) + 
  scale_color_manual(values = c("meth.ffpe" = "orange", "unmeth.ffpe" = "orange", 
                                "meth.frozen" = "purple", "unmeth.frozen" = "purple")) +
  geom_violin(draw_quantiles = c(0.5)) + theme_bw() + theme(legend.position = "none")
```

# Example 3: Identifying probe sets with high and tissue-specific variances

This example describes variance analyses in liver and adipose, 2 of the 7 tissues analyzed in the package manuscript (@maden_human_2020). This includes quality assessments, DNAm linear adjustments on study IDs, probe filters, 2-step variance analysis, and probe set summary plots. All or part of this code can be readily used in variance analyses of additional tissues or sample groups.

## Sample identification and summary

Filter on a vector of GSM IDs of interest `gsmv` (e.g. samples from studies of interest, non-cancer samples, etc.). Define a new samples group variable `sgroup` from querying the `tissue` variable for each tissue of interest.

```{r}
tv <- c("liver", "adipose")
tstr <- paste0(".*", tv, ".*")
mdf <- md[md$gsm %in% gsmv & grepl(paste(tstr, collapse = "|"), md$tissue),]
mdf$sgroup <- ifelse(grepl(tstr[1], mdf$tissue), tv[1], tv[2])
# get samples summary
sst.tvar <- get_sst(sgroup.labs = tv, mdf)
```

Summarize the sample groups.

```{r, eval = TRUE}
kable(sst.tvar, align = "c") # table display
```

## Access DNAm data and plot signals by tissue

Access the `MethylSet` compilation. Append the `sgroup` term and map the array data using genome annotations.

```{r}
ms$sgroup <- mdf$sgroup
ms <- mapToGenome(ms)
```

For quality assessment, calculate log2 median signals. Do not use blocking as in Example 2, as the dataset here is relatively small.

```{r}
l2med.meth <- log2(apply(getMeth(ms), 2, median))
l2med.unmeth <- log2(apply(getUnmeth(ms), 2, median))
lqc <- list("l2med.meth" = l2med.meth, "l2med.unmeth" = l2med.unmeth, "gsmv" = gsmv)
```

Make a scatter plot of the signals by tissue type after corecing `lqc` to a data frame.

```{r, eval = TRUE}
ds <- as.data.frame(do.call(cbind, lqc))
ds$tissue <- as.factor(gsub("\\..*", "", rownames(ds)))
ds[,1] <- as.numeric(ds[,1])
ds[,2] <- as.numeric(ds[,2])

ggplot(ds, aes(x = l2med.meth, y = l2med.unmeth, color = tissue)) + 
  geom_point(alpha = 0.2, cex = 3) + theme_bw() +
  scale_color_manual(values = c("liver" = "blue", "adipose" = "red"))

```

## Perform linear correction on DNAm for study IDs

Access the normalized DNAm Beta-values accessed from the `GenomicRatio` data compilation loaded to the `gr` variable. Perform linear correction on GSE ID using the M-values (logit2-converted Beta-values) with the `removeBatchEffect` function from `limma`.

```{r}
gr$sgroup <- mdf$sgroup
lgr <- lmd <- lb <- lan <- list()
for(t in tv){
  lmv[[t]] <- gr[, gr$sgroup == t]
  gri <- lmv[[t]]
  madj <- limma::removeBatchEffect(getM(gri), batch = gri$gseid)
  lgr[[t]] <- GenomicRatioSet(GenomicRanges::granges(gri), M = madj, 
                               annotation = annotation(gri))
  lmd[[t]] <- pData(lgr[[t]]) <- pData(lmv[[t]])
  metadata(lgr[[t]]) <- list("preprocess" = "noobbeta;removeBatchEffect_gseid")
  lb[[t]] <- getBeta(lgr[[t]])
}
```

## Perform array-wide ANOVAs and filter probes

Prepare data for ANOVAs. Convert variables to either factor or numeric.

```{r}
# prep anova results list
lan <- list()
for(t in tv){
  lan[[t]] <- list("pval" = matrix(ncol = 9, nrow = 0),
                 "var.fract" = matrix(ncol = 9, nrow = 0))
}
# define vars
lvar <- list()
for(ti in 1:length(lmd)){
  for(c in colnames(lmd[[ti]])){
    if(c %in% c("gseid", "predsex")){
      lvar[[ti]][[c]] <- as.factor(lmd[[ti]][,c])
    } else{
      lvar[[ti]][[c]] <- as.numeric(lmd[[ti]][,c])
    }
  }
}
```

Perform array-wide ANOVAs and store results in the `lan` list. These results will inform probe filters within tissue groups.

```{r}
bv <- lb[[1]] # get a full beta-values data set
for(r in 1:nrow(bv)){
  for(t in tv){
    datr <- as.numeric(lb[[t]][r,])
    tvar <- lvar[[t]]
    # do multiple regression and anova
    ld <- lm(datr ~ tvar[[1]] + tvar[[2]] + tvar[[3]] + tvar[[4]] +
                 tvar[[5]] + tvar[[6]] + tvar[[7]] + tvar[[8]] + tvar[[9]])
    an <- anova(ld)
    # get and store results
    ap <- an[c(1:9),5]
    av <- round(100*an[c(1:4),2]/sum(an[,2]), 3)
    lan[[t]][["pval"]] <- rbind(lan[[t]][["pval"]], ap)
    lan[[t]][["var.fract"]] <- rbind(lan[[t]][["var.fract"]], av)
  }
  message(r)
}
```

Organize the ANOVA results in the `lan` object.

```{r}
rnv <- rownames(bv)
cnv <- c("gseid", "predsex", "predage", "predcell.CD8T", "predcell.CD4T",
         "predcell.NK", "predcell.Bcell", "predcell.Mono", "predcell.Gran")
for(ti in 1:length(lan)){
  for(d in 1:length(lan[[ti]])){
    colnames(lan[[ti]][[d]]) <- cnv
    rownames(lan[[ti]][[d]]) <- rnv
  }
}
```

Next, filter probes. First retain just autosomal probes. Then filter on confounder-specific variance contributions with a 0.001 adjusted p-value minimum and 10% variance maximum. Use the Benjamini-Hotchberg method by setting `method = "BH"` in `p.adjust`. Store filtered `GenomicRanges` objects for each tissue in the `lgr.filt` list.

```{r}
pfilt <- 1e-3
varfilt <- 10
lcgkeep <- list() # list of filtered probe sets
anno <- getAnnotation(ms)
xy.cg <- rownames(anno[anno$chr %in% c("chrY", "chrX"),]) # sex chr probes
for(t in tv){
  pm <- lan[[t]]$pval
  vm <- lan[[t]]$var.fract
  # retain autosome cgids
  pm <- pm[!rownames(pm) %in% xy.cg,]
  vm <- vm[!rownames(vm) %in% xy.cg,]
  # parse variable thresholds
  cm <- as.data.frame(matrix(nrow = nrow(pm), ncol = ncol(pm)))
  for(c in 1:ncol(pm)){
    pc <- pm[,c]; 
    pc.adj <- as.numeric(p.adjust(pc, method = "BH"))
    pc.filt <- pc.adj < pfilt
    vc.filt <- vm[,c] >= varfilt
    cm[,c] <- (pc.filt & vc.filt)
  }
  cgkeep <- apply(cm, 1, function(x){return((length(x[x == TRUE]) == 0))})
  lcgkeep[[t]] <- rownames(pm)[cgkeep]
}
lgr.filt <- list("adipose" = lgr[[1]][lcgkeep[[1]],],
                 "liver" = lgr[[2]][lcgkeep[[2]],])
```

## Get probe DNAm summary statistics and analyze variances

Calculate probe DNAm summary statistics. For each tissue, calculate the minima, maxima, means, medians, standard deviations, and variances of Beta-values across samples. Store results in the `lcg.ss` list.

```{r}
cnv <- c("min", "max", "mean", "median", "sd", "var")
mt <- matrix(nrow = 0, ncol = 6)
lcg.ss <- list(mt, mt); names(lcg.ss) <- tv
for(t in tv){
  bt <- as.matrix(getBeta(lgr.filt[[t]]))
  for(r in 1:nrow(bt)){
    x <- bt[r,]
    newrow <- c(min(x), max(x), mean(x), median(x), sd(x), var(x))
    lcg.ss[[t]] <- rbind(lcg.ss[[t]], newrow)
    message(r)
  }
  colnames(lcg.ss[[t]]) <- cnv
  rownames(lcg.ss[[t]]) <- rownames(bt)
}
```

Now perform the main variance analysis. For each tissue, variances are calculated in 2 ways and result in selection of tissue-specific sets of 2,000 probes with the highest-magnitude variances.

Perform the first variance analysis using a 99th quantile filter, and store probes in the `lmvp.abs` list. Since this sets a single variance cutoff for each tissue group, this may be called an "absolute quantile" method.

```{r}
# absolute quantile method
qiv = seq(0, 1, 0.01)
qwhich = c(100)
lmvp.abs <- list()
lci <- list()
for(ti in 1:length(lfilt)){
  ba = as.data.frame(lfilt[[ti]], stringsAsFactors = FALSE)
  q <- qf <- quantile(ba$var, qiv)[qwhich]
  lci[[names(q)]] <- rownames(ba)[ba$var > q]
  lmvp.abs[[names(lfilt)[ti]]] = lci
}
```

Now perform the second variance analysis using binning, or the "bin" method. Probes are first binned based on their mean Beta-values, then selected if they fall above the 99th quantile within their assigned bin. Use N = 10 bins of 0.1 mean Beta-value intervals, and store selected probes in the `lmvp.bin` list. 

```{r}
# binned quantiles method
qiv = seq(0, 1, 0.01) # quantile filter
qwhich = c(100)
bin.xint <- 0.01
binv = seq(0, 1, bin.xint)[1:100] # binned bval mean
# iter on ncts
lmvp.bin = list()
for(ti in 1:length(lfilt)){
  ba = as.data.frame(lfilt[[ti]], stringsAsFactors = FALSE)
  lcg = list()
  # iterate on betaval bins
  for(b in binv){
    # get probes in bin
    bf = ba[ba$mean >= b & ba$mean < b + bin.xint, ] 
    # do bin-specific quantile filter
    q <- qf <- quantile(bf$var, qiv)[qwhich]
    # append probes list
    lcg[[names(q)]] = c(lcg[[names(q)]], rownames(bf)[bf$var > q])
  }
  names(lcg) = paste0("ci:", names(q))
  lmvp.bin[[names(lfilt)[ti]]] = lcg
}
```

With the variance analyses complete, filter the `lmvp.abs` and `lmvp.bin` probes by tissue specificity. Tissue-specific probes should only occur among high variance probes for a single tissue. Categorize probes as "tissue-specific" or "non-specific" as follows.

```{r}
cgav <- c()
for(ti in 1:length(lmvp.abs)){
  txcg <- unique(c(lmvp.abs[[ti]][[1]], lmvp.bin[[ti]][[1]]))
  cgav <- c(cgav, txcg)
}
cgdf <- as.data.frame(table(cgav))
cgdf$type <- ifelse(cgdf[,2] > 1, "non-specific", 
                    "tissue-specific")
```

After filtering probes by tissue specificity, rank them by variances. Select 1,000 probes from `lmvp.abs`, then 1,000 non-overlapping probes from `lmvp.bin`, retaining the 2,000 highest-variance probes by tissue. Store retained probes in `ltxcg`.

```{r}
cgfilt <- cgdf$type == "non-specific"
cgdff <- cgdf[!cgfilt,]
ltxcg <- list()
for(t in 1:length(lmvp.abs)){
  cgtx <- c()
  cgabs <- lmvp.abs[[t]][[1]]
  cgbin <- lmvp.bin[[t]][[1]]
  bt <- as.data.frame(lfilt[[t]])
  # get t tissue specific probes
  filtbt <- rownames(bt) %in% cgdff[,1]
  bt <- bt[filtbt,]
  # get top 1k t tissue specific abs probes
  filt.bf1 <- rownames(bt) %in% cgabs
  bf1 <- bt[filt.bf1,]
  bf1 <- bf1[rev(order(bf1$var)),]
  cgtx <- rownames(bf1)[1:1000]
  # get top 1k t tissue specific bin probes, after filt
  filt.bf2 <- rownames(bt) %in% cgbin &
              !rownames(bt) %in% rownames(bf1)
  bf2 <- bt[filt.bf2,]
  bf2 <- bf2[rev(order(bf2$var)),]
  cgtx <- c(cgtx, rownames(bf2)[1:1000])
  ltxcg[[names(lmvp.abs)[t]]] <- cgtx
}
```

## Violin plots and heatmaps of probe set DNAm means and variances

First, get probe set DNAm summaries and annotation data.

```{r}
# filtered cg summaries
lfcg <- lapply(lfilt, function(x){x <- x[rownames(x) %in% unique(unlist(ltxcg)),]})
# annotation subset
anno <- getAnnotation(lgr[[1]]) # save anno for cga
anno <- anno[,c("Name", "UCSC_RefGene_Name", "Relation_to_Island")]
anno <- anno[rownames(anno) %in% unique(unlist(ltxcg)),]
```

Make violin plots of probe set DNAm using the `makevp()` helper function. This coerces the data into a data set usable in `ggplot2`, and returns plot objects for DNAm means and variances of probe sets in the `lvp` list. Arrange the plot objects with `grid.arrange`.

```{r, eval = TRUE}
lvp <- makevp(lfcg, ltxcg)
grid.arrange(lvp[[1]], lvp[[2]], ncol = 1, bottom = "Tissue")
```

Next, prepare data sets for genome region heatmaps with 3 helper functions. First get region-level coverage using `get_cga()` and a minimum coverage of 2. Next, get region-specific DNAm summaries with `hmsets()`. Finally, make the plot objects with `hmplots()` and display with `grid.arrange`.

```{r, eval = TRUE}
cga <- get_cga(anno)
lhmset <- hmsets(lfcg, cga)
lhmplot <- hmplots(hmma.mean = lhmset[[1]], 
                   hmma.var = lhmset[[2]], 
                   hmma.size = lhmset[[3]])
grid.arrange(lhmplot$hm.mean.plot, lhmplot$hm.var.plot, 
             layout_matrix = matrix(c(rep(1, 7), rep(2, 4)), nrow = 1),
             bottom = "Tissue", left = "Annotation/Region Type")
```

# Conclusions

This vignette described cross-study analyses using data objects accessible with `recountmethylation` and appearing in the manuscript @maden_human_2020. See the manuscript for more information about samples, quality metric signal patterns, and extended variability analyses. For details about data objects, consult the package `users_guide` vignette. Full code and helper function definitions are contained in the `data_analyses.R` companion script. For additional utilities to analyze DNAm compilations, consult the `minfi` and `wateRmelon` packages.

# Session info

```{r get_sessioninfo, eval = TRUE}
sessionInfo()
```

# Works Cited
